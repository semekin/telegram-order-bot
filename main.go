package main

import (
    "fmt"
    "log"
    "net/http"
    "os"
    "strconv"

    "telegram-order-bot/orders"

    tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type BotState int

const (
    StateStart BotState = iota
    StateWaitingForProduct
    StateWaitingForAddress
    StateWaitingForPhone
)

type UserSession struct {
    State   BotState
    Product string
    Address string
}

type OrderBot struct {
    bot          *tgbotapi.BotAPI
    orderManager *orders.OrderManager
    sessions     map[int64]*UserSession
    dispatcherID int64
}

func NewOrderBot(token string, dispatcherID int64) (*OrderBot, error) {
    bot, err := tgbotapi.NewBotAPI(token)
    if err != nil {
        return nil, err
    }

    return &OrderBot{
        bot:          bot,
        orderManager: orders.NewOrderManager(),
        sessions:     make(map[int64]*UserSession),
        dispatcherID: dispatcherID,
    }, nil
}

func (b *OrderBot) StartWebhook() {
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±—Ö—É–∫–∞
    webhookURL := os.Getenv("WEBHOOK_URL")
    if webhookURL != "" {
        _, err := b.bot.SetWebhook(tgbotapi.NewWebhook(webhookURL))
        if err != nil {
            log.Printf("Error setting webhook: %v", err)
        } else {
            log.Printf("Webhook set to: %s", webhookURL)
        }
    }

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ HTTP —Å–µ—Ä–≤–µ—Ä–∞
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }

    http.HandleFunc("/", b.handleRoot)
    http.HandleFunc("/webhook", b.handleWebhook)
    http.HandleFunc("/health", b.handleHealth)

    log.Printf("Starting server on port %s", port)
    log.Fatal(http.ListenAndServe("0.0.0.0:"+port, nil))
}

func (b *OrderBot) StartPolling() {
    u := tgbotapi.NewUpdate(0)
    u.Timeout = 60

    updates := b.bot.GetUpdatesChan(u)

    log.Printf("Starting bot in polling mode")

    for update := range updates {
        if update.Message == nil {
            continue
        }

        b.handleMessage(update.Message)
    }
}

func (b *OrderBot) handleRoot(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Telegram Order Bot is running! üöÄ")
}

func (b *OrderBot) handleHealth(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, "OK")
}

func (b *OrderBot) handleWebhook(w http.ResponseWriter, r *http.Request) {
    update, err := b.bot.HandleUpdate(r)
    if err != nil {
        log.Printf("Error handling update: %v", err)
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    if update.Message != nil {
        b.handleMessage(update.Message)
    }

    w.WriteHeader(http.StatusOK)
}

func (b *OrderBot) handleMessage(message *tgbotapi.Message) {
    userID := message.Chat.ID

    if b.sessions[userID] == nil {
        b.sessions[userID] = &UserSession{State: StateStart}
    }

    session := b.sessions[userID]

    switch session.State {
    case StateStart:
        b.handleStartState(message, session)
    case StateWaitingForProduct:
        b.handleProductInput(message, session)
    case StateWaitingForAddress:
        b.handleAddressInput(message, session)
    case StateWaitingForPhone:
        b.handlePhoneInput(message, session)
    }
}

func (b *OrderBot) handleStartState(message *tgbotapi.Message, session *UserSession) {
    switch message.Text {
    case "/start":
        b.sendWelcomeMessage(message.Chat.ID)
    case "üìã –ü—Ä–∞–π—Å":
        b.sendPriceList(message.Chat.ID)
    case "üõí –°–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑":
        session.State = StateWaitingForProduct
        b.sendMessage(message.Chat.ID,
            "–ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∑–∞–∫–∞–∑–∞—Ç—å? –û–ø–∏—à–∏—Ç–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–∞—à –∑–∞–∫–∞–∑:\n\n"+
                "–ü—Ä–∏–º–µ—Ä: 2 –±–∞–ª—Ç–∏–∫–∏, 1 —Å—É—Ö–∞—Ä–∏–∫–∏, 1 —á–∏–ø—Å—ã")
    default:
        b.sendWelcomeMessage(message.Chat.ID)
    }
}

func (b *OrderBot) handleProductInput(message *tgbotapi.Message, session *UserSession) {
    session.Product = message.Text
    session.State = StateWaitingForAddress

    b.sendMessage(message.Chat.ID, "–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏:")
}

func (b *OrderBot) handleAddressInput(message *tgbotapi.Message, session *UserSession) {
    session.Address = message.Text
    session.State = StateWaitingForPhone

    b.sendMessage(message.Chat.ID, "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –¥–ª—è —Å–≤—è–∑–∏:")
}

func (b *OrderBot) handlePhoneInput(message *tgbotapi.Message, session *UserSession) {
    phone := message.Text

    username := message.From.UserName
    if username == "" {
        username = message.From.FirstName
        if message.From.LastName != "" {
            username += " " + message.From.LastName
        }
    }

    order := b.orderManager.CreateOrder(
        message.Chat.ID,
        username,
        session.Product,
        session.Address,
        phone,
    )

    b.notifyDispatcher(order)
    b.sendOrderConfirmation(message.Chat.ID, order)
    b.sessions[message.Chat.ID] = &UserSession{State: StateStart}
}

func (b *OrderBot) sendWelcomeMessage(chatID int64) {
    text := `üçï –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–µ—Ä–≤–∏—Å –∑–∞–∫–∞–∑–æ–≤!

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:`

    msg := tgbotapi.NewMessage(chatID, text)
    msg.ReplyMarkup = b.getMainKeyboard()

    b.bot.Send(msg)
}

func (b *OrderBot) sendPriceList(chatID int64) {
    text := `üìã –ù–∞—à –ø—Ä–∞–π—Å-–ª–∏—Å—Ç:

üçï –ó–∞–∫—É—Å–æ–Ω:
‚Ä¢ –ß–∏–ø—Å—ã - 150‚ÇΩ
‚Ä¢ –°—É—Ö–∞—Ä–∏–∫–∏ - 150‚ÇΩ

ü•§ –ù–∞–ø–∏—Ç–∫–∏:
‚Ä¢ Coca-Cola - 150‚ÇΩ
‚Ä¢ Fanta - 150‚ÇΩ
‚Ä¢ –í–æ–¥–∞ - 100‚ÇΩ

üç∫ –ê–ª–∫–æ–≥–æ–ª—å:
‚Ä¢ –ë–∞–ª—Ç–∏–∫–∞ - 150‚ÇΩ
‚Ä¢ –≠–ª–ª–µ–π - 150‚ÇΩ
‚Ä¢ –ö–æ—Ä–æ–Ω–∞ –ë–æ—á–∫–∞ - 100‚ÇΩ

üíµ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∑–∞–∫–∞–∑: 500‚ÇΩ
üöö –î–æ—Å—Ç–∞–≤–∫–∞: –±–µ—Å–ø–ª–∞—Ç–Ω–æ –æ—Ç 1000‚ÇΩ`

    b.sendMessage(chatID, text)
}

func (b *OrderBot) sendOrderConfirmation(chatID int64, order orders.Order) {
    text := fmt.Sprintf(`‚úÖ –í–∞—à –∑–∞–∫–∞–∑ –ø—Ä–∏–Ω—è—Ç!

–ù–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞: %s
–ó–∞–∫–∞–∑: %s
–ê–¥—Ä–µ—Å: %s
–¢–µ–ª–µ—Ñ–æ–Ω: %s

–í–∞—à –∑–∞–∫–∞–∑ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω –¥–∏—Å–ø–µ—Ç—á–µ—Ä—É. –° –≤–∞–º–∏ —Å–≤—è–∂—É—Ç—Å—è –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.`,
        order.ID, order.Product, order.Address, order.Phone)

    b.sendMessage(chatID, text)
}

func (b *OrderBot) notifyDispatcher(order orders.Order) {
    if b.dispatcherID == 0 {
        return
    }

    text := fmt.Sprintf(`üö® –ù–û–í–´–ô –ó–ê–ö–ê–ó!

–ù–æ–º–µ—Ä: %s
–ö–ª–∏–µ–Ω—Ç: @%s
–ó–∞–∫–∞–∑: %s
–ê–¥—Ä–µ—Å: %s
–¢–µ–ª–µ—Ñ–æ–Ω: %s
–í—Ä–µ–º—è: %s`,
        order.ID, order.Username, order.Product,
        order.Address, order.Phone, order.CreatedAt.Format("15:04 02.01.2006"))

    b.sendMessage(b.dispatcherID, text)
}

func (b *OrderBot) sendMessage(chatID int64, text string) {
    msg := tgbotapi.NewMessage(chatID, text)
    b.bot.Send(msg)
}

func (b *OrderBot) getMainKeyboard() tgbotapi.ReplyKeyboardMarkup {
    return tgbotapi.NewReplyKeyboard(
        tgbotapi.NewKeyboardButtonRow(
            tgbotapi.NewKeyboardButton("üìã –ü—Ä–∞–π—Å"),
            tgbotapi.NewKeyboardButton("üõí –°–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑"),
        ),
    )
}

func main() {
    botToken := "8409546502:AAHMu4vLc03J-pTXyzcbyvP9TikCVTorllc"
    if botToken == "" {
        log.Fatal("TELEGRAM_BOT_TOKEN environment variable is required")
    }

    dispatcherIDStr := "1155607428"
    var dispatcherID int64 = 0
    if dispatcherIDStr != "" {
        var err error
        dispatcherID, err = strconv.ParseInt(dispatcherIDStr, 10, 64)
        if err != nil {
            log.Printf("Invalid dispatcher ID: %v", err)
        } else {
            log.Printf("Dispatcher notifications enabled for chat ID: %d", dispatcherID)
        }
    }

    bot, err := NewOrderBot(botToken, dispatcherID)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("Authorized on account %s", bot.bot.Self.UserName)

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–∏ –≤–µ–±—Ö—É–∫ –∏–ª–∏ –ø–æ–ª–ª–∏–Ω–≥
    if os.Getenv("RENDER") == "true" || os.Getenv("WEBHOOK_URL") != "" {
        bot.StartWebhook()
    } else {
        bot.StartPolling()
    }
}
